# Tests

## Testing strategy

**Vortex** is a project template, not a traditional application. A change to
a script, configuration file, or workflow can affect every project that uses
it. Because of this, **Vortex** uses a multi-layered testing approach to catch
issues at different levels of integration before they reach consumers.

### Unit testing

[Bats](https://github.com/bats-core/bats-core) is used to unit test the
shell scripts in `scripts/vortex/`. Each script is tested in isolation with
external commands (like `drush`, `docker`, `composer`) replaced by mocks.
This allows us to verify that individual scripts handle environment variables,
flags, and edge cases correctly without needing a running Drupal site or
Docker containers.

The [`bats-helpers`](https://github.com/drevops/bats-helpers) library provides
a step-based testing approach with built-in mocking and assertions, making it
straightforward to define expected inputs and outputs for each script.

Unit tests execute in seconds, providing fast feedback during development.
There are 25+ test files covering deployment, database operations,
notifications, provisioning, and other automation scripts.

:::info

Scripts are transitioning from Bash to PHP in **Vortex** `2.0`, which will
make the use of BATS obsolete. Track the progress
in [this issue](https://github.com/drevops/vortex/issues/1192).

:::

### End-to-end testing

[PHPUnit](https://phpunit.de/) is used for functional end-to-end testing that
exercises the full site build pipeline in real Docker containers. These tests
simulate what a consumer site developer would experience: installing the
template, building containers, importing databases, running Drupal operations,
linting code, and deploying artifacts.

The end-to-end tests cover several critical workflows:

- **Installer** - verifying that a fresh project can be scaffolded from the
  template and that custom files are preserved during updates.
- **Docker Compose** - building the container stack, verifying environment
  variables, running linters, executing PHPUnit and Behat tests inside
  containers, and checking Solr integration.
- **Ahoy workflows** - testing the full developer experience through Ahoy
  commands, including build, login, Drush operations, Composer, database
  import/export, and code quality checks.
- **Deployment** - testing deployment pipelines for artifact and webhook-based
  deployment strategies.

The [`phpunit-helpers`](https://github.com/AlexSkrypnyk/phpunit-helpers)
library provides test helpers, traits, and assertions purpose-built for running
shell commands and validating their output within PHPUnit tests.

End-to-end tests take minutes to run because they operate on real containers
and a real Drupal site, but they provide the highest confidence that
everything works together correctly.

### Example site

The [DrevOps website](https://github.com/drevops/website) is a real-world
production site built using **Vortex**. It serves as the ultimate validation
ground: if **Vortex** works correctly, the website should continue to build,
test, and deploy without issues after each upstream update.

The website repository receives regular upstream updates from **Vortex**,
including CI configuration, testing workflows, and infrastructure changes.
This ensures that updates are validated against a real, long-lived codebase
rather than just in test environments.

## Running tests

### Functional tests with PHPUnit

```shell
cd .vortex/tests

# Install Composer dependencies.
composer install

# Run all tests.
composer test

# Some tests require Composer and container registry tokens.
TEST_PACKAGE_TOKEN=<yourtoken> TEST_VORTEX_CONTAINER_REGISTRY_USER=<youruser> TEST_VORTEX_CONTAINER_REGISTRY_PASS=<yourpass> composer test
```

Functional tests rely on database fixtures - see the section below on
[updating test assets](#updating-test-assets).

### Unit tests with BATS

```shell
cd .vortex/tests

# Install npm dependencies.
npm install

# Run a single test.
bats .vortex/tests/bats/deploy.bats
```

## Updating test assets

There are *demo* and *test* database dumps captured as *files* and *container images*.

- Demo database dump file - *demonstration* of the database import capabilities from a *file*.
- Demo database container image - *demonstration* of the database import capabilities from a *container image*.
- Test database dump file - *test* of the database import capabilities from a *file*.
- Test database container image - *test* of the database import capabilities from a *container image*.

### Updating *demo* database dump *file*

<details>
<summary>Show instructions</summary>

1. Run fresh build of **Vortex** locally:
```shell
rm .data/db.sql || true
VORTEX_PROVISION_TYPE=profile VORTEX_PROVISION_POST_OPERATIONS_SKIP=1 AHOY_CONFIRM_RESPONSE=1 ahoy build
```
2. Update content and config:
```shell
ahoy cli

drush eval "Drupal::entityTypeManager()->getStorage('node')->create([
  'type' => 'page',
  'title' => 'Welcome to the demo site!',
  'body' => [
    'value' => '<p>This demo page is sourced from the Vortex database dump file to demonstrate database importing capabilities.</p>',
    'format' => 'basic_html',
  ],
])->save();"

drush config:set system.site page.front "/node/1" -y
drush sql:query "SHOW TABLES LIKE 'cache_%'" | xargs -I{} drush sql:query "TRUNCATE TABLE {}" && drush sql:query "TRUNCATE TABLE watchdog"

exit

```
3. Export DB:
```shell
ahoy export-db db.demo.sql
```
4. Upload `db.demo.sql` to the latest release as an asset and name it `db_d11.demo.sql`.

</details>

### Updating *demo* database *container image*

<details>
<summary>Show instructions</summary>

1. Run fresh build of **Vortex** locally:
```shell
rm .data/db.sql || true
VORTEX_PROVISION_TYPE=profile VORTEX_PROVISION_POST_OPERATIONS_SKIP=1 AHOY_CONFIRM_RESPONSE=1 ahoy build
```
2. Update content and config:
```shell
ahoy cli

drush eval "Drupal::entityTypeManager()->getStorage('node')->create([
  'type' => 'page',
  'title' => 'Welcome to the demo site!',
  'body' => [
    'value' => '<p>This demo page is sourced from the Vortex database container image to demonstrate database importing capabilities.</p>',
    'format' => 'basic_html',
  ],
])->save();"

drush config:set system.site page.front "/node/1" -y
drush sql:query "SHOW TABLES LIKE 'cache_%'" | xargs -I{} drush sql:query "TRUNCATE TABLE {}" && drush sql:query "TRUNCATE TABLE watchdog"

exit

```
3. Export DB:
```shell
ahoy export-db db.demo_image.sql

# Update the collation to avoid issues with MariaDB 10.5+:
sed -i '' 's/utf8mb4_0900_ai_ci/utf8mb4_general_ci/g' .data/db.demo_image.sql
```
4. Seed the database container image:
```shell
curl -LO https://github.com/drevops/mariadb-drupal-data/releases/latest/download/seed.sh
chmod +x seed.sh
./seed.sh .data/db.demo_image.sql drevops/vortex-dev-mariadb-drupal-data-demo-11.x:latest
```

</details>

### Updating *test* database dump *file*

<details>
<summary>Show instructions</summary>

1. Run a fresh install of **Vortex** into a new directory and name the project `Star Wars`:
```shell
mkdir /tmp/star-wars
VORTEX_INSTALLER_TEMPLATE_REPO="$(pwd)" .vortex/installer/installer.php /tmp/star-wars --no-interaction
cd /tmp/star-wars
```
2. Run fresh build of **Vortex** locally:
```shell
rm .data/db.sql || true
VORTEX_PROVISION_TYPE=profile AHOY_CONFIRM_RESPONSE=1 ahoy build
```
3. Update content and config:
```shell
ahoy cli

drush eval "Drupal::entityTypeManager()->getStorage('node')->create([
  'type' => 'page',
  'title' => 'Welcome to the test site!',
  'body' => [
    'value' => '<p>This test page is sourced from the Vortex database dump file to demonstrate database importing capabilities.</p>',
    'format' => 'basic_html',
  ],
])->save();"

drush config:set system.site page.front "/node/1" -y
drush sql:query "SHOW TABLES LIKE 'cache_%'" | xargs -I{} drush sql:query "TRUNCATE TABLE {}" && drush sql:query "TRUNCATE TABLE watchdog"

exit

```
4. Export DB:
```shell
ahoy export-db db.test.sql
```
5. Upload `db.test.sql` to the latest release as an asset and name it `db_d11.test.sql`.

</details>

### Updating *test* database *container image*

<details>
<summary>Show instructions</summary>

1. Run a fresh install of **Vortex** into a new directory and name the project `Star Wars`:
```shell
mkdir /tmp/star-wars
VORTEX_INSTALLER_TEMPLATE_REPO="$(pwd)" .vortex/installer/installer.php /tmp/star-wars --no-interaction
cd /tmp/star-wars
```
2. Run fresh build of **Vortex** locally:
```shell
rm .data/db.sql || true
VORTEX_PROVISION_TYPE=profile AHOY_CONFIRM_RESPONSE=1 ahoy build
```
3. Update content and config:
```shell
ahoy cli

drush eval "Drupal::entityTypeManager()->getStorage('node')->create([
  'type' => 'page',
  'title' => 'Welcome to the test site!',
  'body' => [
    'value' => '<p>This test page is sourced from the Vortex database container image to demonstrate database importing capabilities.</p>',
    'format' => 'basic_html',
  ],
])->save();"

drush config:set system.site page.front "/node/1" -y
drush sql:query "SHOW TABLES LIKE 'cache_%'" | xargs -I{} drush sql:query "TRUNCATE TABLE {}" && drush sql:query "TRUNCATE TABLE watchdog"

exit

```
4. Export DB:
```shell
ahoy export-db db.test_image.sql

# Update the collation to avoid issues with MariaDB 10.5+:
sed -i '' 's/utf8mb4_0900_ai_ci/utf8mb4_general_ci/g' .data/db.test_image.sql
```
5. Seed the database container image:
```shell
curl -LO https://github.com/drevops/mariadb-drupal-data/releases/latest/download/seed.sh
chmod +x seed.sh
./seed.sh .data/db.test_image.sql drevops/vortex-dev-mariadb-drupal-data-test-11.x:latest
```
6. Update destination container images:
```shell
docker tag drevops/vortex-dev-mariadb-drupal-data-demo-11.x:latest drevops/vortex-dev-mariadb-drupal-data-demo-destination-11.x:vortex-dev-database-ii
docker push drevops/vortex-dev-mariadb-drupal-data-demo-destination-11.x:vortex-dev-database-ii

docker tag drevops/vortex-dev-mariadb-drupal-data-demo-11.x:latest drevops/vortex-dev-mariadb-drupal-data-demo-destination-11.x:vortex-dev-didi-database-fi
docker push drevops/vortex-dev-mariadb-drupal-data-demo-destination-11.x:vortex-dev-didi-database-fi
```

</details>
