#!/usr/bin/env php
<?php

declare(strict_types=1);

/**
 * Generate .circleci/vortex-test-common.yml from build-test-deploy.yml.
 *
 * Extracts aliases, database and build jobs from the main CircleCI config
 * and assembles them with DIDI variant jobs into a single test config.
 *
 * Usage:
 *   php .vortex/tests/generate-vortex-dev-circleci         # Generate
 *   php .vortex/tests/generate-vortex-dev-circleci --check  # Check
 */

$check_mode = in_array('--check', $argv ?? []);

$root_dir = dirname(__DIR__, 2);
$source_file = $root_dir . '/.circleci/build-test-deploy.yml';
$output_file = $root_dir . '/.circleci/vortex-test-common.yml';

$content = file_get_contents($source_file);
if ($content === FALSE) {
  fwrite(STDERR, sprintf("Error: Cannot read %s\n", $source_file));
  exit(1);
}

$lines = explode("\n", $content);

$aliases = extract_aliases($lines);
$database_job = extract_job($lines, '/^  database: &job-database/');
$build_job = extract_job($lines, '/^  build: &job_build/');

$output = implode("\n", [
  '# Auto-generated by .vortex/tests/generate-vortex-dev-circleci',
  '# Source: .circleci/build-test-deploy.yml',
  '# Do not edit directly.',
  "version: '2.1'",
  '',
  $aliases,
  '',
  '################################################################################',
  '# JOBS',
  '################################################################################',
  '',
  'jobs:',
  '  # Base jobs as anchor sources (not referenced in any workflow).',
  $database_job,
  '',
  $build_job,
  '',
  '  # DIDI-FI variant jobs',
  build_variant_job('vortex-dev-didi-database-fi', '*job-database', [
    'VORTEX_DOWNLOAD_DB_SOURCE' => 'url',
    'VORTEX_DOWNLOAD_DB_FORCE' => 1,
    'VORTEX_DB_IMAGE' => 'drevops/vortex-dev-mariadb-drupal-data-demo-destination-11.x',
    'VORTEX_DEPLOY_CONTAINER_REGISTRY_IMAGE_TAG' => 'vortex-dev-didi-database-fi',
    'VORTEX_EXPORT_DB_CONTAINER_REGISTRY_DEPLOY_PROCEED' => 1,
    'VORTEX_CI_DB_CACHE_BRANCH' => 'vortex-dev-didi-fi',
  ]),
  '',
  build_variant_job('vortex-dev-didi-build-fi', '*job_build', [
    'VORTEX_DB_IMAGE' => 'drevops/vortex-dev-mariadb-drupal-data-demo-destination-11.x:vortex-dev-didi-database-fi',
    'VORTEX_CI_DB_CACHE_BRANCH' => 'vortex-dev-didi-fi',
    'MIGRATION_SKIP' => 1,
  ]),
  '',
  '  # DIDI-II variant jobs',
  build_variant_job('vortex-dev-database-ii', '*job-database', [
    'VORTEX_DOWNLOAD_DB_SOURCE' => 'VORTEX_CONTAINER_REGISTRY',
    'VORTEX_DOWNLOAD_DB_FORCE' => 1,
    'VORTEX_DB_IMAGE' => 'drevops/vortex-dev-mariadb-drupal-data-demo-destination-11.x',
    'VORTEX_DEPLOY_CONTAINER_REGISTRY_IMAGE_TAG' => 'vortex-dev-database-ii',
    'VORTEX_EXPORT_DB_CONTAINER_REGISTRY_DEPLOY_PROCEED' => 1,
    'VORTEX_CI_DB_CACHE_BRANCH' => 'vortex-dev-didi-ii',
  ]),
  '',
  build_variant_job('vortex-dev-didi-build-ii', '*job_build', [
    'VORTEX_DB_IMAGE' => 'drevops/vortex-dev-mariadb-drupal-data-demo-destination-11.x:vortex-dev-database-ii',
    'VORTEX_CI_DB_CACHE_BRANCH' => 'vortex-dev-didi-ii',
    'MIGRATION_SKIP' => 1,
  ]),
  '',
  '################################################################################',
  '# WORKFLOWS',
  '################################################################################',
  '',
  'workflows:',
  '  vortex-dev-didi-fi:',
  '    jobs:',
  '      - vortex-dev-didi-database-fi',
  '      - vortex-dev-didi-build-fi:',
  '          requires:',
  '            - vortex-dev-didi-database-fi',
  '',
  '  vortex-dev-didi-ii:',
  '    jobs:',
  '      - vortex-dev-database-ii',
  '      - vortex-dev-didi-build-ii:',
  '          requires:',
  '            - vortex-dev-database-ii',
  '',
]);

if ($check_mode) {
  if (!file_exists($output_file)) {
    fwrite(STDERR, sprintf("Error: %s does not exist. Run without --check to generate.\n", $output_file));
    exit(1);
  }

  $existing = file_get_contents($output_file);
  if ($existing !== $output) {
    fwrite(STDERR, sprintf("Error: %s is out of date. Run 'php .vortex/tests/generate-vortex-dev-circleci' to update.\n", $output_file));
    exit(1);
  }

  echo sprintf("OK: %s is up to date.\n", $output_file);
  exit(0);
}

file_put_contents($output_file, $output);
echo sprintf("Generated: %s\n", $output_file);

/**
 * Extract the aliases section from the source lines.
 *
 * @param list<string> $lines
 *   Source file lines.
 */
function extract_aliases(array $lines): string {
  $start = NULL;
  $end = count($lines);

  for ($i = 0, $count = count($lines); $i < $count; $i++) {
    $line = $lines[$i];
    if ($start === NULL) {
      if (preg_match('/^aliases:/', $line)) {
        $start = $i;
      }
      continue;
    }

    // Stop at first non-empty, non-indented line after aliases.
    if ($line !== '' && !preg_match('/^\s/', $line)) {
      $end = $i;
      break;
    }
  }

  if ($start === NULL) {
    fwrite(STDERR, "Error: Could not find aliases section.\n");
    exit(1);
  }

  $result = array_slice($lines, $start, $end - $start);

  // Trim trailing blank lines.
  while (!empty($result) && trim(end($result)) === '') {
    array_pop($result);
  }

  return implode("\n", $result);
}

/**
 * Extract a job block from the source lines.
 *
 * @param list<string> $lines
 *   Source file lines.
 */
function extract_job(array $lines, string $pattern): string {
  $start = NULL;

  for ($i = 0, $count = count($lines); $i < $count; $i++) {
    if (preg_match($pattern, $lines[$i])) {
      $start = $i;
      break;
    }
  }

  if ($start === NULL) {
    fwrite(STDERR, sprintf("Error: Could not find job matching %s.\n", $pattern));
    exit(1);
  }

  $result = [$lines[$start]];

  for ($i = $start + 1, $count = count($lines); $i < $count; $i++) {
    $line = $lines[$i];
    // Stop at the next block at job level (2-space indent) or top level.
    if ($line !== '' && (preg_match('/^  \S/', $line) || preg_match('/^\S/', $line))) {
      break;
    }
    $result[] = $line;
  }

  // Trim trailing blank lines.
  while (!empty($result) && trim(end($result)) === '') {
    array_pop($result);
  }

  return implode("\n", $result);
}

/**
 * Build a DIDI variant job YAML block.
 *
 * @param array<string, string|int> $env
 *   Environment variable overrides.
 */
function build_variant_job(string $name, string $anchor, array $env): string {
  $lines = [
    sprintf('  %s:', $name),
    sprintf('    <<: %s', $anchor),
    '    environment:',
  ];

  foreach ($env as $key => $value) {
    $lines[] = sprintf('      %s: %s', $key, $value);
  }

  return implode("\n", $lines);
}
